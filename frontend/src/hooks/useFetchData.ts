import { RefObject, useCallback, useMemo, useState } from "react";
import {
  AgGridSortDirection,
  DashboardRecordSort,
  DashboardSamplesQueryVariables,
} from "../generated/graphql";
import { useHookLazyGeneric } from "../shared/types";
import { parseUserSearchVal } from "../utils/parseSearchQueries";
import { getColumnFilters } from "../shared/helpers";
import { IServerSideGetRowsParams } from "ag-grid-community";
import { AgGridReact as AgGridReactType } from "ag-grid-react/lib/agGridReact";
import { usePhiEnabled } from "../contexts/PhiEnabledContext";

export const CACHE_BLOCK_SIZE = 500; // number of rows to fetch at a time

interface UseFetchDataProps {
  /**
   * The lazy query hook generated by graphql-codegen.
   */
  useRecordsLazyQuery: typeof useHookLazyGeneric;
  /**
   * The fieldName in the column definitions to use for the initial sort.
   */
  initialSortFieldName: string;
  /**
   * Additional contexts to filter records by that are always included in the query.
   * For example, in the Request Samples view, the `igoRequestId` context is always included
   * in each query to filter samples by the request they belong to.
   */
  contexts?: DashboardSamplesQueryVariables["contexts"];
  /**
   * Polling interval in milliseconds.
   * https://www.apollographql.com/docs/react/data/queries#polling
   */
  pollInterval?: number;
  /**
   * The name of the query to use for fetching data matching that in the GraphQL schema.
   * Examples: "dashboardRequests", "dashboardSamples", "dashboardPatients"
   */
  queryName: string;
  /**
   * A reference to the AgGridReact component.
   * Used to set the server-side datasource for the grid.
   */
  gridRef: RefObject<AgGridReactType>;
  /**
   * The current user search value from the search box.
   * Used to re-fetch data when the user performs a new search.
   */
  userSearchVal: string;
}

export function useFetchData({
  useRecordsLazyQuery,
  initialSortFieldName,
  contexts = [],
  pollInterval = 0, // no polling
  queryName,
  gridRef,
  userSearchVal,
}: UseFetchDataProps) {
  // Manage our own loading state becase the lazy query's provided `loading` state
  // does not toggle to `true` as `setServerSideDatasource` is running
  const [loading, isLoading] = useState(false);
  const { phiEnabled } = usePhiEnabled();

  const defaultSort: DashboardRecordSort = useMemo(
    () => ({
      colId: initialSortFieldName,
      sort: AgGridSortDirection.Desc,
    }),
    [initialSortFieldName]
  );

  const [, { error, data, fetchMore, refetch, startPolling, stopPolling }] =
    useRecordsLazyQuery({
      variables: {
        searchVals: [],
        contexts,
        sort: defaultSort,
        limit: CACHE_BLOCK_SIZE,
        offset: 0,
        phiEnabled,
      },
      pollInterval,
    });

  const recordCount: number = data?.[queryName][0]?._total || 0;

  const buildServerSideDatasource = useCallback(
    (userSearchVal) => {
      return {
        getRows: async (params: IServerSideGetRowsParams) => {
          isLoading(true);

          const queryVariables = {
            searchVals: parseUserSearchVal(userSearchVal),
            contexts,
            sort: params.request.sortModel[0] || defaultSort,
            limit: CACHE_BLOCK_SIZE,
            offset: params.request.startRow ?? 0,
            columnFilters: getColumnFilters(params),
          };

          const thisFetch =
            params.request.startRow === 0
              ? refetch(queryVariables)
              : fetchMore({
                  variables: queryVariables,
                });

          return thisFetch
            .then((result) => {
              params.success({
                rowData: result.data[queryName],
                rowCount: result.data[queryName][0]?._total || 0,
              });
            })
            .catch((error) => {
              console.error(error);
              params.fail();
            })
            .finally(() => {
              isLoading(false);
            });
        },
      };
    },
    [refetch, fetchMore, defaultSort, queryName, contexts]
  );

  async function refreshData() {
    const newDatasource = buildServerSideDatasource(userSearchVal);
    // Update the grid with new data
    gridRef.current?.api.setServerSideDatasource(newDatasource);
  }

  return {
    refreshData,
    recordCount,
    loading,
    error,
    data,
    fetchMore,
    refetch,
    startPolling,
    stopPolling,
  };
}
